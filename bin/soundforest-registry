#!/usr/bin/env python
"""
Script to manage soundforest music tree registrations
"""

import os

from systematic.shell import normalized, Script, ScriptError
from soundforest.database.models import Tree, SoundForestDB, SoundForestDBError
from soundforest.tags import TagError
from soundforest.tags.formats import Tags

DEFAULT_TREE_TYPE = 'Songs'

INFO_STRING="""%(path)s
Tree Type:   %(type)s
Alias Paths: %(aliases)s
Total Files: %(file_count)s
Directories: %(directory_count)s"""

USAGE = """Usage: %(script)s [options] <tree paths>

Register, update and verify music file trees in soundforest sqlite database.

Terms used:
- Tree type is used for grouping the resulting trees in programs using it
  If not specified, 'Songs' (music library) is used as default type.
- Tree source can be given, if same path is used from multiple programs,
  to register same tree for each program. If not specified, 'filesystem'
  is used as source."""

script = Script()
script.add_argument('-l', '--list', action='store_true', help='List trees')
script.add_argument('-i', '--info', action='store_true', help='Show details for registered path')
script.add_argument('-x', '--extension', help='File extension to filter with')
script.add_argument('-L', '--list-types', action='store_true', help='List tree types')
script.add_argument('-D', '--list-directories', action='store_true', help='List directories found in a tree')
script.add_argument('-r', '--register', action='store_true', help='Register trees')
script.add_argument('-u', '--unregister', action='store_true', help='Unregister trees')
script.add_argument('-s', '--scan-updates', action='store_true', help='Scan trees')
script.add_argument('-S', '--tree-source', default='filesystem', help='Tree source')
script.add_argument('-e', '--verify', action='store_true', help='Verify file types in trees')
script.add_argument('-c', '--update-checksums', action='store_true', help='Update file SHA1 checksum while scanning trees')
script.add_argument('-C', '--cleanup', action='store_true', help='Remove deleted files from database')
script.add_argument('-t', '--tree-type', help='Tree type, default is Songs')
script.add_argument('paths', nargs='*', help='Paths to process')
args = script.parse_args()

if args.register and args.unregister:
    script.exit(1, 'Flags --register and --unregister conflict.')

tree_type = None
if args.register or args.unregister:
    if args.tree_type is not None:
        tree_type = args.tree_type
    else:
        tree_type = DEFAULT_TREE_TYPE

try:
    db = SoundForestDB(message_callback=args.debug and script.log.debug or None)
except SoundForestDBError, emsg:
    db = None
    script.exit(1, emsg)

if args.register:
    for path in args.paths:
        script.log.debug('Registering: %s' % path)
        tree = Tree(db, path, args.tree_source, tree_type)
        db.register_tree(tree)

elif args.unregister:
    for path in args.paths:
        script.log.debug('Unregistering: %s' % path)
        tree = Tree(db, path, args.tree_source, tree_type)
        db.unregister_tree(tree)
    script.exit(0)

if not args.paths:
    trees = db.get_trees()
else:
    trees = []
    for path in args.paths:
        tree = db.match_tree(path)
        if tree is None:
            script.exit(1, 'Unknown tree path: %s' % path)
        trees.append(tree)

if args.scan_updates:
    for t in trees:
        changes = t.update(args.update_checksums)
        for path in [os.path.join(t.path, x) for x in changes['added']]:
            print 'Updating tags for new file: %s' % path
            Tags(path).update()
        for path in [os.path.join(t.path, x) for x in changes['modified']]:
            print 'Updating tags for modified file: %s' % path

if args.update_checksums and not args.scan_updates:
    for t in trees:
        for entry in t:
            entry.update_checksum()

if args.cleanup:
    for t in trees:
        t.remove_deleted()

if args.list_types:
    for name, description in db.tree_types:
        print '%-16s %s' % (name, description)

if args.list:
    for t in trees:
        print '%-16s %s' % (t.source, t.path)

if args.info:
    for t in trees:
        if args.extension:
            filecount = len(t.match_extension(args.extension))
        else:
            filecount = len(t.files)
        print INFO_STRING % ({
            'type': t.tree_type,
            'path': t.path,
            'aliases': ', '.join(t.aliases),
            'directory_count': len(t.directories),
            'file_count': filecount,
        })

if args.list_directories:
    for t in trees:
        for relative_path in t.directories:
            print relative_path
            if args.verbose:
                print '\t%s' % '\n\t'.join(str(f) for f in t.directory_files(relative_path))

if args.verify:
    for t in trees:
        script.log.info('Verifying tree files: %s' % t.path)
        for entry in t:
            if entry.filetype=='unknown':
                script.log.info('UNKNOWN: %s' % entry.realpath)

