#!/usr/bin/env python
"""
Script to manage soundforest music tree registrations
"""

import os

from systematic.shell import normalized,Script,ScriptError
from soundforest.database.models import Tree,SoundForestDB,SoundForestDBError

DEFAULT_TREE_TYPE = 'Songs'

INFO_STRING="""%(path)s
Tree Type:   %(type)s
Alias Paths: %(aliases)s
Total Files: %(file_count)s
Directories: %(directory_count)s"""

USAGE = """Usage: %(script)s [options] <tree paths>

Register, update and verify music file trees in soundforest sqlite database.

Terms used:
- Tree type is used for grouping the resulting trees in programs using it
  If not specified, 'Songs' (music library) is used as default type.
- Tree source can be given, if same path is used from multiple programs,
  to register same tree for each program. If not specified, 'filesystem'
  is used as source."""

script = Script()
script.set_usage(USAGE % {'script': script.name})
script.add_option('-l','--list',action='store_true',help='List trees')
script.add_option('-i','--info',action='store_true',help='Show details for registered path')
script.add_option('-x','--extension',help='File extension to filter with')
script.add_option('-L','--list-types',action='store_true',help='List tree types')
script.add_option('-D','--list-directories',action='store_true',help='List directories found in a tree')
script.add_option('-r','--register',action='store_true',help='Register trees')
script.add_option('-u','--unregister',action='store_true',help='Unregister trees')
script.add_option('-s','--scan-updates',action='store_true',help='Scan trees')
script.add_option('-S','--tree-source',help='Tree source, default is filesystem')
script.add_option('-e','--verify',action='store_true',help='Verify file types in trees')
script.add_option('-c','--update-checksums',action='store_true',help='Update file SHA1 checksum while scanning trees')
script.add_option('-C','--cleanup',action='store_true',help='Remove deleted files from database')
script.add_option('-t','--tree-type',help='Tree type, default is Songs')
script.set_defaults(**{'tree_source':'filesystem'})
(opts,args) = (None,None)
try:
    (opts,args) = script.parse_args()
except ScriptError,emsg:
    script.exit(1,emsg)

if opts.register and opts.unregister:
    script.exit(1,'Flags --register and --unregister conflict.')

tree_type = None
if opts.register or opts.unregister:
    if opts.tree_type is not None:
        tree_type = opts.tree_type
    else:
        tree_type = DEFAULT_TREE_TYPE

try:
    db = SoundForestDB(message_callback=opts.debug and script.log.debug or None)
except SoundForestDBError,emsg:
    db = None
    script.exit(1,emsg)

if opts.register:
    for path in args:
        script.log.debug('Registering: %s' % path)
        tree = Tree(db,path,opts.tree_source,tree_type)
        db.register_tree(tree)

elif opts.unregister:
    for path in args:
        script.log.debug('Unregistering: %s' % path)
        tree = Tree(db,path,opts.tree_source,tree_type)
        db.unregister_tree(tree)
    script.exit(0)

if not args:
    trees = db.get_trees()
else:
    trees = []
    for path in args:
        tree = db.match_tree(path)
        if tree is None:
            script.exit(1,'Unknown tree path: %s' % path)
        trees.append(tree)

if opts.scan_updates:
    for t in trees:
        changes = t.update(opts.update_checksums)

if opts.update_checksums and not opts.scan_updates:
    for t in trees:
        for entry in t:
            entry.update_checksum()

if opts.cleanup:
    for t in trees:
        t.remove_deleted()

if opts.list_types:
    for name,description in db.tree_types:
        print '%-16s %s' % (name,description)

if opts.list:
    for t in trees:
        print '%-16s %s' % (t.source,t.path)

if opts.info:
    for t in trees:
        if opts.extension:
            filecount = len(t.match_extension(opts.extension))
        else:
            filecount = len(t.files)
        print INFO_STRING % ({
            'type': t.tree_type,
            'path': t.path,
            'aliases': ', '.join(t.aliases),
            'directory_count': len(t.directories),
            'file_count': filecount,
        })

if opts.list_directories:
    for t in trees:
        for relative_path in t.directories:
            print relative_path
            if opts.verbose:
                print '\t%s' % '\n\t'.join(str(f) for f in t.directory_files(relative_path))

if opts.verify:
    for t in trees:
        script.log.info('Verifying tree files: %s' % t.path)
        for entry in t:
            if entry.filetype=='unknown':
                script.log.info('UNKNOWN: %s' % entry.realpath)

